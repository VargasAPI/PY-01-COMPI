

package ParserLexer;
import java_cup.runtime.*;
 
// utiliza class BasicLexerCup que genera el lexer .jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:
// este es el cup este es el analinzador lexico
// meter funciones en action code para la tabla de simbolos, agregar un simbolo a una tabla, generar un simbolo
// funciones java en action code
action code {:
 
    public void hola(){
        System.out.println("Iniciando lectura del codigo....");
    }
 
    public void adios(){
        System.out.println("Lectura finalizada de manera exitosa");
    }
:}
 
parser code {:
    BasicLexerCup lex;
   
    @SuppressWarnings("deprecation")
    public parser(BasicLexerCup lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }


    
 
:}
 
init with {: :};
 
/* define how to connect to the scanner! */
scan with {: return lex.next_token(); :}
 


/* Terminales (tokens retornados por el scanner). */
/*definicion de tipos*/
terminal L_INTEGER, L_STRING, IDENTIFICADOR, L_FLOAT, L_CHAR, MAIN_T;
 /*tipos*/
terminal INTEGER_T, STRING_T, CHAR_T, FLOAT_T, BOLEANO_T, VOID_T; 
/*boleano*/
terminal FALSE_T, TRUE_T;   
/*signo*/
terminal SUMA_T,RESTA_T, MULTIPLICACION_T,POTENCIA_T, DIVISION_T, MODULO_T;
/*operadores relacionales*/ 
terminal COMPARACION_T, DIFERENTE_T, MAYOR_IGUAL_T, MENOR_IGUAL_T, MAYOR_T, MENOR_T;
/*signos de comparacion*/
terminal MAS_IGUAL_T, MENOS_IGUAL_T, ASIGNA, DIV_IGUAL_T, MOD_IGUAL_T, POT_IGUAL_T;
/*signos unitarios*/
terminal INCREMENTO_T, DECREMENTO_T;
/*operadores logaritmicos y negacion*/
terminal CONJUNCION_T, NEGACION_T, DISYUNCION_T; 
/*estructuras de control*/ 
terminal IF_T, ELSE_T,  DO_T, ELIF_T, WHILE_T, FOR_T;
/*sentencias de control*/
terminal RETURN_T,BREAK_T, CIN_T, COUT_T;
/*OTROS SIGNOS*/
terminal OP_INSERT_T, OP_EXTRACT_T;
terminal FINLINEA, COMA, PARENTESIS_I,PARENTESIS_D, LLAVE_ABIERTO_T, LLAVE_CERRADO_T;
terminal PIPE, CORCHETE_D, CORCHETE_I;

// no terminales

non terminal tipoFunc, tipo, signo, signoComp, operadorRel, operadorLog, boleano;
non terminal sigUnitario, nombreFuncion,variable;

non terminal parametros,parametrosInv, invocaFunc,paramInv ,exprP;

non terminal cajaArray, defArray, array,params;

non terminal operandoUnitario, operandoArit, literal ,operandos,operacionArit,cambiable;

non terminal asignacion, creacion, asignArit, creacionAsig, asigCompuesta,asignacionUni,asignacionGeneral;

non terminal filas, matriz ;

non terminal exprUni, crear,creaciones;

non terminal exprRel_I, exprRel_glob ,exprRel_par ,exprRel_neg, operandoLog, exprLog_I;
non terminal lista_read, lista_write, write, read, return_A;

non terminal for_B, while_B , doWhile_B, else_C, elif_C, if_C, optn, control;

non terminal expr, bloque, programa, funcMain, main;


non terminal inicio, decS, dec, funcFunc, func;
//produccion de inicio
start with programa;



/*
------------------------------------------------------
TIPOS Y SIGNOS
------------------------------------------------------
*/
literal ::=  L_INTEGER | L_CHAR | L_STRING | L_FLOAT ;

tipoFunc ::= INTEGER_T | VOID_T | FLOAT_T | CHAR_T | BOLEANO_T; 

tipo ::= INTEGER_T | STRING_T | FLOAT_T | CHAR_T | BOLEANO_T;
/*signo ::= + | - | // | ~ | **    */
signo ::= SUMA_T | RESTA_T | MULTIPLICACION_T | POTENCIA_T | DIVISION_T | MODULO_T ;
/*signoComp ::= += | -= | //= | ~= | **=   */
signoComp ::= MAS_IGUAL_T | MENOS_IGUAL_T |  DIV_IGUAL_T | MOD_IGUAL_T | POT_IGUAL_T ;
/*operadorRel  < | > | <= | >= | != | == */
operadorRel ::= COMPARACION_T | DIFERENTE_T | MAYOR_IGUAL_T | MENOR_IGUAL_T | MAYOR_T | MENOR_T;
/*operadorLog::= ^ | # */
operadorLog ::= CONJUNCION_T | DISYUNCION_T;
/*boleano := Sol | Luna*/
boleano ::= FALSE_T | TRUE_T;
/*sigUnitario ::= ++ | --*/
sigUnitario ::= INCREMENTO_T | DECREMENTO_T;

nombreFuncion ::= IDENTIFICADOR;
variable ::= IDENTIFICADOR;


/*
------------------------------------------------------
ARRAY
------------------------------------------------------
*/

cajaArray ::= CORCHETE_I operandoArit CORCHETE_D ;
defArray ::= cajaArray  
        | defArray cajaArray;
array ::= variable defArray;

/*
------------------------------------------------------
LLAMAR FUNCIONES AUX
------------------------------------------------------
*/


parametros ::= operandoArit 
            | parametros COMA operandoArit 
            | /*vacio*/;


invocaFunc ::=  IDENTIFICADOR PARENTESIS_I parametros PARENTESIS_D ;  

/*
------------------------------------------------------
DECLARACION DE MATRIZ
------------------------------------------------------
*/

filas ::= operandoArit 
        | filas COMA operandoArit;

matriz ::= PIPE filas  PIPE ;

/*
------------------------------------------------------
OPERANDOS
------------------------------------------------------
*/

operandoUnitario ::= variable sigUnitario | sigUnitario variable ;

operandoArit ::= literal |  operandoUnitario | boleano | array | matriz | invocaFunc ;  



operacionArit ::= operandoArit
            |  NEGACION_T operandoArit
            |  operacionArit signo operandoArit
            |  PARENTESIS_I operacionArit signo operandoArit PARENTESIS_D
            |  NEGACION_T PARENTESIS_I operacionArit signo operandoArit PARENTESIS_D;
            

/*
------------------------------------------------------
CREACION, ASIGNACION , CREACION-ASIGNACION (INCLUYE ARRAYS)
------------------------------------------------------
*/

cambiable ::= variable | array;

creacion ::= tipo cambiable | creacion COMA tipo cambiable | ;
asignArit ::= cambiable ASIGNA exprP ;
creacionAsig ::= tipo cambiable ASIGNA exprP ;
asignacion::= creacion | asignArit | creacionAsig;

//asignArit ::= cambiable ASIGNA exprP ;
//crear ::= asignArit | cambiable;
//creaciones ::= crear | creaciones COMA crear ;
//creacionAsig ::= tipo creaciones | creacionAsig COMA tipo creaciones  ;
//asignacion::= asignArit | creacionAsig;

asigCompuesta ::= cambiable signoComp operacionArit
                | PARENTESIS_I cambiable signoComp operacionArit PARENTESIS_D; 

asignacionUni ::= asignacion  FINLINEA;

/*
------------------------------------------------------
EXPRESIONES RELACIONALES Y  LOGICAS
------------------------------------------------------
*/
exprRel_I ::=  operacionArit operadorRel operacionArit ;
exprRel_par ::= PARENTESIS_I operacionArit operadorRel operacionArit  PARENTESIS_D ;
exprRel_neg ::= NEGACION_T PARENTESIS_I operacionArit operadorRel operacionArit  PARENTESIS_D ;
exprRel_glob ::= exprRel_I | exprRel_par | exprRel_neg ;

operandoLog ::= asigCompuesta   | exprRel_glob  | operacionArit ;

exprLog_I ::= operandoLog  
            | exprLog_I  operadorLog operandoLog
            | NEGACION_T PARENTESIS_I exprLog_I  operadorLog operandoLog PARENTESIS_D 
            | PARENTESIS_I exprLog_I  operadorLog operandoLog PARENTESIS_D  ;


exprP ::= exprLog_I;
exprUni ::= exprP FINLINEA;

/*
------------------------------------------------------
READ - WRITE - RETURN 
------------------------------------------------------
*/

lista_read ::= OP_INSERT_T exprP
            | lista_read OP_INSERT_T exprLog_I ;

read ::= CIN_T lista_read FINLINEA ; 

lista_write ::= OP_EXTRACT_T exprP
              | lista_write OP_EXTRACT_T exprLog_I ;
              
write::= COUT_T lista_write FINLINEA ;

return_A::= RETURN_T exprP  FINLINEA | RETURN_T FINLINEA;

/*
------------------------------------------------------
FOR
------------------------------------------------------
*/

for_B::= FOR_T PARENTESIS_I asignacionUni exprUni exprP PARENTESIS_D LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T ;

/*
------------------------------------------------------
DO - WHILE
------------------------------------------------------
*/


while_B::= WHILE_T PARENTESIS_I exprP PARENTESIS_D LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T;

doWhile_B::= DO_T LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T WHILE_T PARENTESIS_I exprP PARENTESIS_D FINLINEA;

/*
------------------------------------------------------
ELSE - ELIF - IF
------------------------------------------------------
*/

else_C::= ELSE_T LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T ;

elif_C::= ELIF_T PARENTESIS_I exprP PARENTESIS_D LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T ;

if_C ::= IF_T PARENTESIS_I exprP PARENTESIS_D LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T;

optn ::= if_C | elif_C | else_C ;
/*
------------------------------------------------------
PRINCIPAL
------------------------------------------------------
*/


control::=  for_B | while_B | doWhile_B | optn ;

expr ::= exprUni | read | write | return_A | control | asignacionUni ;
bloque ::= expr | bloque expr ;

params ::= PARENTESIS_I creacion  PARENTESIS_D ;

main ::= VOID_T MAIN_T params ;
funcMain ::= main FINLINEA
            | main LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T;


func ::= tipoFunc nombreFuncion params ;
funcFunc ::= func FINLINEA
            | func LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T;


dec ::= funcFunc ; // agregar que pude ser vacio, creo que no deja

decS ::= dec
        | decS dec;

inicio ::= decS funcMain;


programa ::= {: hola();:} inicio {: adios();:} ;