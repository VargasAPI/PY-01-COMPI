package ParserLexer;
import java_cup.runtime.*;
 
// utiliza class BasicLexerCup que genera el lexer .jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:
// este es el cup este es el analinzador lexico
// meter funciones en action code para la tabla de simbolos, agregar un simbolo a una tabla, generar un simbolo
// funciones java en action code
action code {:
 
    public void hola(){
        System.out.println("Iniciando lectura del codigo....");
    }
 
    public void adios(){
        System.out.println("Lectura finalizada de manera exitosa");
    }
:}
 
parser code {:
    BasicLexerCup lex;
   
    @SuppressWarnings("deprecation")
    public parser(BasicLexerCup lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
 
:}
 
init with {: :};
 
/* define how to connect to the scanner! */
scan with {: return lex.next_token(); :}
 
/* Terminales (tokens retornados por el scanner). */
/*definicion de tipos*/
terminal L_INTEGER, L_STRING, IDENTIFICADOR,IDENTIFICADOR2, L_FLOAT, L_CHAR;
 /*tipos*/
terminal INTEGER_T, STRING_T, CHAR_T, FLOAT_T, BOLEANO_T, VOID_T; 
/*boleano*/
terminal FALSE_T, TRUE_T;   
/*signo*/
terminal SUMA_T,RESTA_T, MULTIPLICACION_T,POTENCIA_T, DIVISION_T, MODULO_T;
/*operadores relacionales*/ 
terminal COMPARACION_T, DIFERENTE_T, MAYOR_IGUAL_T, MENOR_IGUAL_T, MAYOR_T, MENOR_T;
/*signos de comparacion*/
terminal MAS_IGUAL_T, MENOS_IGUAL_T, ASIGNA, DIV_IGUAL_T, MOD_IGUAL_T, POT_IGUAL_T;
/*signos unitarios*/
terminal INCREMENTO_T, DECREMENTO_T;
/*operadores logaritmicos y negacion*/
terminal CONJUNCION_T, NEGACION_T, DISYUNCION_T; 
/*estructuras de control*/ 
terminal IF_T, ELSE_T,  DO_T, ELIF_T, WHILE_T, FOR_T;
/*sentencias de control*/
terminal RETURN_T,BREAK_T, CIN_T, COUT_T;
/*OTROS SIGNOS*/
terminal OP_INSERT_T, OP_EXTRACT_T;
terminal FINLINEA, COMA, PARENTESIS, LLAVE_ABIERTO_T, LLAVE_CERRADO_T;
terminal PIPE, CORCHETE_D, CORCHETE_I;
// no terminales
non terminal programa, bloque, expr, operandos,tipo;
non terminal signo, signoComp, operadorRel, operadorLog, tipoFunc, boleano;
non terminal sigUnitario, operadorUnitario;


non terminal arrays, creacionArray, asignArray, creacionAsigArray, array, defArray, cajaArray;
non terminal contenido_simple, contenido_multiple, matriz_simple, matriz;
non terminal filas, fila, columnas, columna;


non terminal asignacion, creacion, asignArit, creacionAsig, asigCompuesta, operacionArit;

non terminal exprRel_I, operandoLog, exprLog_I,exprUni ;
non terminal lista_read,doWhile_B,for_B,asignacion_FOR, if_C,lista_write, read,paramCallfun,elif_list, opt_else, control, write, return_A,elemento_write, while_B ;
non terminal else_C, elif_C, sent, optn ;
//produccion de inicio
start with programa;

programa ::= {: hola();:} bloque {: adios();:} ;


 

signo ::= SUMA_T | RESTA_T | MULTIPLICACION_T | POTENCIA_T | DIVISION_T | MODULO_T ;
/*signoComp ::= += , -= , //= , ~= , **=   */
signoComp ::= MAS_IGUAL_T | MENOS_IGUAL_T |  DIV_IGUAL_T | MOD_IGUAL_T | POT_IGUAL_T ;
operadorRel ::= COMPARACION_T | DIFERENTE_T | MAYOR_IGUAL_T | MENOR_IGUAL_T | MAYOR_T | MENOR_T;
operadorLog ::= CONJUNCION_T | DISYUNCION_T;

tipoFunc ::= INTEGER_T | VOID_T | FLOAT_T | CHAR_T | BOLEANO_T; 
boleano ::= FALSE_T | TRUE_T;
sigUnitario ::= INCREMENTO_T | DECREMENTO_T;
operadorUnitario ::= IDENTIFICADOR sigUnitario | sigUnitario IDENTIFICADOR ;


arrays ::= creacionArray | asignArray | creacionAsigArray | array;
creacionArray ::= tipo  IDENTIFICADOR defArray;
asignArray ::=  IDENTIFICADOR defArray ASIGNA matriz ;
creacionAsigArray ::= tipo IDENTIFICADOR defArray ASIGNA matriz ;

/*a[2][fun(1)]*/
array ::= IDENTIFICADOR defArray ;
defArray ::= cajaArray  | defArray cajaArray;
cajaArray ::= CORCHETE_I operandos CORCHETE_D ;


contenido_simple ::=  PIPE operandos PIPE | operandos ;
//contenido_multiple ::=  (contenido_simple COMA)* contenido_simple ;

contenido_multiple ::=  contenido_simple | contenido_multiple filas ;
filas ::= fila | filas fila;
fila ::= COMA contenido_simple;

matriz_simple ::= PIPE contenido_multiple PIPE  ;
matriz ::= PIPE columnas matriz_simple PIPE ;
columnas ::= columna | columnas columna;
columna ::= matriz_simple COMA;


/*debo de llamar en operandos array o matriz*/
/*añadir | <paramCallfun> */
operandos ::= L_INTEGER | L_CHAR | L_STRING | L_FLOAT | boleano  | operadorUnitario | array  |IDENTIFICADOR| paramCallfun ;
tipo ::= INTEGER_T | STRING_T | FLOAT_T | CHAR_T | BOLEANO_T;

asignacion::= creacion | asignArit | creacionAsig ;
creacion ::= tipo IDENTIFICADOR ;
asignArit ::= IDENTIFICADOR ASIGNA exprLog_I ;
creacionAsig ::= tipo IDENTIFICADOR ASIGNA exprLog_I ;

paramCallfun ::=  IDENTIFICADOR2  PARENTESIS  PARENTESIS ;

asigCompuesta ::= IDENTIFICADOR  signoComp operacionArit; /*mejorar esta combinacion*/

operacionArit ::= operandos
            |  NEGACION_T operandos 
            |  operacionArit signo operandos 
            |  NEGACION_T PARENTESIS operacionArit signo operandos PARENTESIS 
            |  PARENTESIS operacionArit signo operandos PARENTESIS ;


exprRel_I ::= operacionArit
            | operacionArit operadorRel operacionArit
            | NEGACION_T PARENTESIS operacionArit operadorRel operacionArit PARENTESIS 
            | PARENTESIS  operacionArit operadorRel operacionArit PARENTESIS ;

operandoLog ::= asigCompuesta   | exprRel_I ;


exprLog_I ::= operandoLog 
            | exprLog_I  operadorLog operandoLog
            | NEGACION_T PARENTESIS exprLog_I  operadorLog operandoLog PARENTESIS 
            | PARENTESIS exprLog_I  operadorLog operandoLog PARENTESIS ;


exprUni ::= exprLog_I FINLINEA;










lista_write ::= OP_EXTRACT_T exprLog_I
              | lista_write OP_EXTRACT_T exprLog_I ;
              
write::= COUT_T lista_write FINLINEA ;


 lista_read ::= OP_INSERT_T exprLog_I
              | lista_read OP_INSERT_T exprLog_I ; 

read ::= CIN_T lista_read  FINLINEA ;


while_B::= WHILE_T PARENTESIS exprLog_I PARENTESIS LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T {: System.out.println("Si llega while"); :};

doWhile_B::= DO_T LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T WHILE_T PARENTESIS exprLog_I PARENTESIS FINLINEA {: System.out.println("Si llega doWhile"); :};




          
else_C::= ELSE_T LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T {: System.out.println("Si llega else"); :};

elif_C::= ELIF_T PARENTESIS exprLog_I PARENTESIS LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T {: System.out.println("Si llega elif"); :};

if_C ::= IF_T PARENTESIS exprLog_I PARENTESIS LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T   {: System.out.println("If con múltiples elif y opcional else"); :};


asignacion_FOR::= creacion | asignArit | creacionAsig | asignacion COMA asignacion ;


for_B::= FOR_T PARENTESIS asignacion_FOR FINLINEA  {:System.out.println("Si");:}exprLog_I  FINLINEA operadorUnitario PARENTESIS LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T {: System.out.println("Si llega for"); :};

optn::= if_C | elif_C | else_C ;


control::= while_B | doWhile_B | optn | for_B ;


return_A::= RETURN_T operandos  FINLINEA | RETURN_T FINLINEA;

bloque ::= expr | bloque expr ;

expr ::= return_A  | read | write | control  | exprUni | asignacion FINLINEA ;

