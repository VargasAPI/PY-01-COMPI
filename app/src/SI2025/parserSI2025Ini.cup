

package ParserLexer;
import java_cup.runtime.*;
 
// utiliza class BasicLexerCup que genera el lexer .jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:
// este es el cup este es el analinzador lexico
// meter funciones en action code para la tabla de simbolos, agregar un simbolo a una tabla, generar un simbolo
// funciones java en action code
action code {:
    String currentHastTable;
 
    public void hola(){
        System.out.println("Iniciando lectura del codigo....");
    }
 
    public void adios(){
        System.out.println("Lectura finalizada de manera exitosa");
    }
    public void crearTabla(String funcion){
        currentHastTable = funcion;
        System.out.println("Tabla de simbolos para: "+funcion + "\n");    

    }
    public void leerTipoID(String tipo, String identificador){
        System.out.println("Tipo          |"+tipo); 
        System.out.println("identificador |"+identificador); 
        
    }

    public void leerObjeto(String mensaje, String objeto){
        System.out.println(mensaje+"       | "+objeto);
    }
:}
 
parser code {:
    BasicLexerCup lex;
   
    @SuppressWarnings("deprecation")
    public parser(BasicLexerCup lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }


    
 
:}
 
init with {: :};
 
/* define how to connect to the scanner! */
scan with {: return lex.next_token(); :}
 


/* Terminales (tokens retornados por el scanner). */
/*definicion de tipos*/
terminal L_INTEGER, L_STRING, IDENTIFICADOR, L_FLOAT, L_CHAR;
 /*tipos*/
terminal INTEGER_T, STRING_T, CHAR_T, FLOAT_T, BOLEANO_T, VOID_T; 
/*boleano*/
terminal FALSE_T, TRUE_T;   
/*signo*/
terminal SUMA_T,RESTA_T, MULTIPLICACION_T,POTENCIA_T, DIVISION_T, MODULO_T;
/*operadores relacionales*/ 
terminal COMPARACION_T, DIFERENTE_T, MAYOR_IGUAL_T, MENOR_IGUAL_T, MAYOR_T, MENOR_T;
/*signos de comparacion*/
terminal MAS_IGUAL_T, MENOS_IGUAL_T, ASIGNA, DIV_IGUAL_T, MOD_IGUAL_T, POT_IGUAL_T;
/*signos unitarios*/
terminal INCREMENTO_T, DECREMENTO_T;
/*operadores logaritmicos y negacion*/
terminal CONJUNCION_T, NEGACION_T, DISYUNCION_T; 
/*estructuras de control*/ 
terminal IF_T, ELSE_T,  DO_T, ELIF_T, WHILE_T, FOR_T;
/*sentencias de control*/
terminal RETURN_T,BREAK_T, CIN_T, COUT_T;
/*OTROS SIGNOS*/
terminal OP_INSERT_T, OP_EXTRACT_T;
terminal FINLINEA, COMA, PARENTESIS_I,PARENTESIS_D, LLAVE_ABIERTO_T, LLAVE_CERRADO_T;
terminal PIPE, CORCHETE_D, CORCHETE_I;

// no terminales

non terminal tipoFunc, tipo, signo, signoComp, operadorRel, operadorLog, boleano;
non terminal sigUnitario;

non terminal cajaArray, defArray, array,corchete_d,corchete_i;
non terminal filas, matriz,declara,coma ;

non terminal parametros, invocaFunc ,exprP;


non terminal literal ,operandoUnitario, operandoArit,operacionArit,exprAritNegacion;
non terminal cambiable,creacion,asignArit,creacionAsig,asignacion,asigCompuesta,asignacionUni;
non terminal exprArit,exprAritParentesis;
non terminal exprUni;

non terminal exprRel_I, exprRel_glob ,exprRel_par ,exprRel_neg, operandoLog, exprLog_I;
non terminal lista_read, lista_write, write, read, return_A;

non terminal for_B, while_B , doWhile_B, else_C, elif_C, if_C, optn, control;



non terminal expr, bloque, programa,decFun ;


non terminal inicio, decS, dec, funcMain, params;
//produccion de inicio
start with programa;



/*
------------------------------------------------------
TIPOS Y SIGNOS
------------------------------------------------------
*/
literal ::=  L_INTEGER:itr {:RESULT="entero";:}  | L_CHAR:chr {:RESULT="caranter";:} 
            | L_STRING:strg {:RESULT="cadena";:}  | L_FLOAT:flot  {:RESULT="decimal";:} ;

tipoFunc ::= INTEGER_T:it {:RESULT="int";:}  | VOID_T:vd {:RESULT="void";:} 
            | FLOAT_T:ft {:RESULT="float";:} | CHAR_T:ch {:RESULT="char";:} 
            | BOLEANO_T:bl {:RESULT="bool";:};

tipo ::= INTEGER_T:it {:RESULT="int";:} | STRING_T:str {:RESULT="string";:} 
        | FLOAT_T:ft {:RESULT="float";:} | CHAR_T:ch {:RESULT="char";:} 
        | BOLEANO_T:bl {:RESULT="bool";:};

signo ::= SUMA_T:sum {:RESULT="+";:} | RESTA_T:res {:RESULT="-";:}  
        | MULTIPLICACION_T:multi  {:RESULT="*";:} 
        | POTENCIA_T:pot  {:RESULT="**";:} | DIVISION_T:div {:RESULT="//";:} 
        | MODULO_T:mod  {:RESULT="~";:} ;

signoComp ::= MAS_IGUAL_T:masi {:RESULT="+=";:} | MENOS_IGUAL_T:mini {:RESULT="-=";:} 
            |  DIV_IGUAL_T:di {:RESULT="//=";:} | MOD_IGUAL_T:modi {:RESULT="~=";:}
            | POT_IGUAL_T:pi {:RESULT="**=";:} ;
/*operadorRel  < | > | <= | >= | != | == */
operadorRel ::= COMPARACION_T:cmp {:RESULT="==";:} | DIFERENTE_T:dif {:RESULT="!=";:} 
                | MAYOR_IGUAL_T:myi {:RESULT=">=";:} | MENOR_IGUAL_T:mni {:RESULT="<=";:} 
                | MAYOR_T:my {:RESULT=">";:} | MENOR_T:mn {:RESULT="<";:};
/*operadorLog::= ^ | # */
operadorLog ::= CONJUNCION_T:and {:RESULT="#";:} | DISYUNCION_T:or {:RESULT="^ ";:};
/*boleano := Sol | Luna*/
boleano ::= FALSE_T:sol {:RESULT="Sol";:} | TRUE_T:luna {:RESULT="Luna";:};
/*sigUnitario ::= ++ | --*/
sigUnitario ::= INCREMENTO_T:incre {:RESULT="++";:} | DECREMENTO_T:decre  {:RESULT="--";:};


/*
------------------------------------------------------
ARRAY
------------------------------------------------------
*/


cajaArray ::= CORCHETE_I  operandoArit:opA CORCHETE_D 
            {:RESULT="["+opA.toString()+"]";:};
defArray ::= cajaArray:cjarr {: RESULT = cjarr.toString();:}
        | defArray:dfarr cajaArray:cjarr {: RESULT = dfarr.toString() + cjarr.toString();:};
array ::= IDENTIFICADOR:id defArray:dfArray
         {:leerObjeto("Arreglo", id.toString()+ dfArray.toString()); 
         RESULT =id.toString()+ dfArray.toString();:} ;

/*
------------------------------------------------------
DECLARACION DE MATRIZ
------------------------------------------------------
filas ::= operandoArit
        | filas COMA operandoArit

matriz ::= PIPE filas PIPE 
        
*/


filas ::= operandoArit:opAr {: RESULT = opAr.toString(); :}
        | filas:fl COMA operandoArit:opAr 
          {: RESULT = fl.toString() + "," + opAr.toString(); :} ;

matriz ::= PIPE  filas:fls PIPE 
            {:leerObjeto("Matriz", "|"+fls.toString()+ "|"); 
            RESULT="|"+fls.toString()+"|";:};

/*
------------------------------------------------------
LLAMAR FUNCIONES AUX
------------------------------------------------------
*/
parametros ::= operandoArit:opAr {: RESULT = opAr.toString(); :}
        | parametros:prm COMA operandoArit:opAr 
          {: RESULT = prm.toString() + "," + opAr.toString(); :} ;

invocaFunc ::= IDENTIFICADOR:id PARENTESIS_I parametros:param PARENTESIS_D 
            {:leerObjeto("Llamada funcion", id.toString()+ "["+ param.toString()+"]"); 
            RESULT=id.toString()+ "["+ param.toString()+"]";:};
/*
------------------------------------------------------
OPERANDOS
------------------------------------------------------
*/
operandoUnitario ::= IDENTIFICADOR:id sigUnitario:sigU 
                {:leerObjeto("Operador Unitario", id.toString()+ sigU.toString()); 
                RESULT=id.toString()+ sigU.toString();:}
                | sigUnitario:sigU IDENTIFICADOR:id 
                {:leerObjeto("Operador Unitario", sigU.toString()+id.toString()); 
                RESULT=sigU.toString()+id.toString();:};


operandoArit ::= literal:lit {:leerObjeto("Literal",lit.toString());  RESULT = lit.toString();:} 
                | IDENTIFICADOR:id {:leerObjeto("ID",id.toString()); RESULT = id.toString();:} 
                | invocaFunc:invFun {: RESULT = invFun.toString();:}
                | exprAritParentesis
                | boleano:bol {:leerObjeto("Boleano",bol.toString());  RESULT = bol.toString();:} 
                | array:arr {: RESULT = arr.toString();:}
                | matriz:mt {: RESULT = mt.toString();:}
                | operandoUnitario:opU  {: RESULT = opU.toString();:}
                | exprAritNegacion;

/*
------------------------------------------------------
CREACION, ASIGNACION , CREACION-ASIGNACION (INCLUYE ARRAYS)
------------------------------------------------------
idea borrar array:arr linea 209
*/


cambiable ::= IDENTIFICADOR:id {:RESULT = id.toString();:} | array;

creacion ::= tipo:tp cambiable:camb {:leerTipoID(tp.toString(),camb.toString());:}
            | creacion COMA tipo:tp cambiable:camb {:leerTipoID(tp.toString(),camb.toString());:}
            | ;
asignArit ::= cambiable ASIGNA exprP ;
declara ::= tipo:tp cambiable:camb {:leerTipoID(tp.toString(),camb.toString());:};
creacionAsig ::= declara ASIGNA exprP ;
asignacion::= creacion | asignArit | creacionAsig;


asigCompuesta ::= cambiable signoComp:sig {:leerObjeto("Operador compuesto",sig.toString());:} exprArit; 

asignacionUni ::= asignacion  FINLINEA;

/*
------------------------------------------------------
EXPRESIONES RELACIONALES Y  LOGICAS
------------------------------------------------------
*/

exprArit ::= operandoArit:opArt 
            | NEGACION_T operandoArit
            |  exprArit signo:sig {:leerObjeto("Operador Aritmetico",sig.toString());:} operandoArit;



exprRel_I ::=  exprArit operadorRel:sig {:leerObjeto("Operador relacional",sig.toString());:} exprArit ;

operandoLog ::= asigCompuesta | exprRel_I  | exprArit  ;

exprLog_I ::= operandoLog  
            | exprLog_I  operadorLog:opl {:leerObjeto("Operador logaritmico",opl.toString());:} operandoLog;

exprAritParentesis ::=  PARENTESIS_I exprLog_I PARENTESIS_D ;



exprP ::= exprLog_I;
exprUni ::= exprP FINLINEA ;

expr ::= exprUni | asignacionUni ;
bloque ::= expr | bloque expr ;

params ::= PARENTESIS_I creacion  PARENTESIS_D ;

decFun ::= tipoFunc IDENTIFICADOR:id  {: crearTabla(id.toString()); RESULT = id.toString();:};
funcMain ::= decFun:idF params FINLINEA
            | decFun:idF params  LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T
            {: RESULT = idF.toString();:};

dec ::= funcMain:deffun 
        {: System.out.println("\nFin de la tala de simbolos "+deffun.toString() + "\n"); :} ; 

decS ::= dec
        | decS dec;

inicio ::= decS;

programa ::= {: hola();:} inicio {: adios();:} ;